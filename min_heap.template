/*
* Author: Jordan Ball
* Assignment: Project 2
* Class: CS3610
* Date: 2/25/2018
*
* Description: MinHeap class that is templated to be used with any data type
*
*/

#include "min_heap.h"
#include <algorithm>
#include <cstdlib>
#include <iostream>

using namespace std;

// Input: 
//      data - User data.
//      key  - Key value associated with user data.
//             Use key to organize user data into min
//             heap container.
template <typename T>
void MinHeap<T>::insert(const T data, const int key){
	if (heap.empty()) {
		heap.push_back(HeapNode<T>(data, key));
	}
	else {
		heap.push_back(HeapNode<T>(data, key));
		int pos = heap.size() - 1;
		BubbleUp(pos);
	}
}

// Return: User data stored in HeapNode with minimum key value.
template <typename T>
T MinHeap<T>::extract_min() {
	if (heap.empty()) {
		cerr << "Empty Heap\n";
		exit(EXIT_FAILURE);
	}
	else {
		int i = heap.size() - 1;
		HeapNode<T> tmp = heap[0];
		heap[0] = heap[i];
		heap[i] = tmp;

		T dat = heap[i].data;
		heap.pop_back();

		BubbleDown(0);

		return dat;
	}
}

// Return: User data stored in HeapNode with minimum key value.
template <typename T>
T MinHeap<T>::peek() const {
	if (heap.empty()) {
		cerr << "Empty Heap\n";
		exit(EXIT_FAILURE);
	}
	else {
		return heap[0].data;
	}
}

// Return: Size of the min heap.
template <typename T>
int MinHeap<T>::size() const {
	return heap.size();
}

template<typename T>
void MinHeap<T>::BubbleUp(int i) {
	if (i == 0 || heap[Parent(i)].key <= heap[i].key) {
		return; //base case
	}
	else {
		HeapNode<T> tmp = heap[i]; //swap
		heap[i] = heap[Parent(i)];
		heap[Parent(i)] = tmp;

		BubbleUp(Parent(i)); //recursive call
	}
}

//swaps the node at i with the greater child if present
template<typename T>
void MinHeap<T>::BubbleDown(int i) {
	if(HasLeft(i) && HasRight(i)){
		if(heap[i].key <= heap[Left(i)].key && heap[i].key <= heap[Right(i)].key){
			return;
		} else if(heap[Left(i)].key == heap[Right(i)].key) {
			HeapNode<T> tmp = heap[Left(i)];
			heap[Left(i)] = heap[i];
			heap[i] = tmp;
			BubbleDown(Left(i));
		} else {
			int j = heap[Left(i)].key;
			int k = heap[Right(i)].key;
			int min_key = min(j, k);
			if (j == min_key) {
				HeapNode<T> tmp = heap[Left(i)];
				heap[Left(i)] = heap[i];
				heap[i] = tmp;
				BubbleDown(Left(i));
			}
			else {
				HeapNode<T> tmp = heap[Right(i)];
				heap[Right(i)] = heap[i];
				heap[i] = tmp;
				BubbleDown(Right(i));
			}
		}
	} else if(HasLeft(i) && !HasRight(i)){
		if(heap[i].key <= heap[Left(i)].key){
			return;		
		} else {
			HeapNode<T> tmp = heap[Left(i)];
			heap[Left(i)] = heap[i];
			heap[i] = tmp;
			BubbleDown(Left(i));
		}
	} else if(HasRight(i) && !HasLeft(i)){
		if(heap[i].key <= heap[Right(i)].key){
			return;		
		} else {
			HeapNode<T> tmp = heap[Right(i)];
			heap[Right(i)] = heap[i];
			heap[i] = tmp;
			BubbleDown(Right(i));
		}
	} else {
		return;
	} 
}

//print function to help with debugging
/*

template<typename T>
void MinHeap<T>::print() {
	typename vector< HeapNode<T> >::iterator it;
	for (it = heap.begin(); it != heap.end(); it++) {
		// cout << (*it).data << " ";
		cout << it->data->character << " ";
	}
}
*/


template<typename T>
int MinHeap<T>::Left(int i){
	int l = (2*i)+1;
	return l;
}

template<typename T>
int MinHeap<T>::Parent(int i){
	int p = (i-1) / 2;
	return p;
}

template<typename T>
int MinHeap<T>::Right(int i){
	int r = (2*i)+2;
	return r;
}

template<typename T>
bool MinHeap<T>::HasRight(int i){
	if(Right(i) < int(heap.size())){
		return true;
	} else {
		return false;
	}
}

template<typename T>
bool MinHeap<T>::HasLeft(int i){
	if(Left(i) < int(heap.size())){
		return true;
	} else {
		return false;
	}
}